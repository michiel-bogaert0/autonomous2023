import numpy as np
import json
import copy
import math
import random


class Track:
    """
    This code converts a track to the cone locations (normally handled in the ROS pipeline)

    Global reference space: y+ top and x+ right, normal angles
    Car space: rotated by 90deg -> x+ top (forwards), y+ left, normal angles
    """

    def __init__(self, file_path: str, expand_dist: float, plan_distance: float):
        """
        Initialise a track from a file path

        Args:
            file_path: The json track file. This file is generated by the track-editor,
            but has three extra properties in the parameters: startpos_x, startpos_y, startrot.
            expand_dist: The distance with which we follow the generated center line each iteration.
            plan_distance: The max distance we can detect cones in from of the car.
        """
        with open(file_path, "r") as f:
            track = json.load(f)

        self.track = track

        self.cones = []
        self.cones_car_space = []
        self.center_line_car_space = []


        # The track editor uses the OpenCV coordinate space (x+ right and y+ down)
        # We will change this to the standard coordinate space by swapping the colours of blue and yellow cones
        # (in fact mirroring the cones in reference to the center line of the track)
        # 0 --> blue
        # 1 --> yellow
        # 2 --> orange big
        # 3 --> orange small
        # 4 --> unknown

        self.colors = ["blue", "yellow", "orange_big", "orange_small", "unknown"]
        for color in self.colors:
            if color in track["cones"]:
                self.cones += [
                    np.array([c["pos"][0], c["pos"][1],
                              self.colors.index(color)]) for c in track["cones"][color]]
        self.cones = np.array(self.cones)

        track_params = track["parameters"]
        self.ref_to_car = (track_params["startpos_x"], track_params["startpos_y"], track_params["startrot"])
        self.expand_dist = expand_dist
        self.plan_distance = plan_distance

        #self.center_line = self.get_center_line()

        self.update_cones()

    def update_car_pos(self, pos: "Node"):
        theta = np.arctan2(pos.y, pos.x)
        angle_change = (theta + np.pi) % (2 * np.pi) - np.pi

        distance = np.sqrt(pos.x ** 2 + pos.y ** 2)
        new_angle = angle_change + self.ref_to_car[2]

        self.ref_to_car = (
            self.ref_to_car[0] + min(self.expand_dist, distance) * np.cos(new_angle),
            self.ref_to_car[1] + min(self.expand_dist, distance) * np.sin(new_angle),
            new_angle,
        )

        self.update_cones()

    def absolute_update(self, x: float, y: float, rot: float):
        self.ref_to_car = (x, y, rot)
        self.update_cones()
        
    def update_cones(self):
        """
        Update the positions of cones and center line in the car reference space given the ground truth global reference space cone positions
        """
        cones_copy = copy.deepcopy(self.cones)
        transformed_cones_pos = self.real_to_car_transform(cones_copy[:, :-1])

        # Reset the colour info
        cones_copy[:, :-1] = transformed_cones_pos

        self.cones_car_space = cones_copy

        #center_line_copy = copy.deepcopy(self.center_line)
        #transformed_center_line = self.real_to_car_transform(center_line_copy[:, :-1])

        # Also update angle info
        #center_line_copy[:, :-1] = transformed_center_line
        #center_line_copy[:, -1] -= self.ref_to_car[2]

        #self.center_line_car_space = center_line_copy

    def add_cone_noise(self, cones: np.ndarray, colour_prob: float, pos_prob: float, pos_radius: float) -> np.ndarray:
        """
        Given a list of cones, add noise in the form of random colour and position changes.

        Args:
            cones: List of cones to add noise to.
            colour_prob: The chance of a colour change happening.
            pos_prob: The chance of a position change happening.
            pos_radius: The maximum distance the position can change.
        """
        for cone in cones:
            rand = np.random.rand(2)

            if rand[0] < colour_prob:
                cone[2] = 1 if cone[2] == 0 else 0

            if rand[1] < pos_prob:
                theta = 2 * math.pi * random.random()
                cone[0] += np.cos(theta) * pos_radius * random.random()
                cone[1] += np.sin(theta) * pos_radius * random.random()

        return cones

    def real_to_car_transform(self, objects: np.ndarray) -> np.ndarray:
        """
        Returns an array of objects that are converted from global reference space to car reference space.
        """
        orig_pos = np.c_[objects, np.ones(objects.shape[0])]

        trans = np.array([[1, 0, -self.ref_to_car[0]], [0, 1, -self.ref_to_car[1]], [0, 0, 1]])
        rot = np.array([[math.cos(self.ref_to_car[2]), -math.sin(-self.ref_to_car[2]), 0],
                        [math.sin(-self.ref_to_car[2]), math.cos(self.ref_to_car[2]), 0], [0, 0, 1]])
        new_pos = (rot @ trans @ orig_pos.T).T

        return new_pos[:, :-1]

    def car_to_real_transform(self, objects: np.ndarray) -> np.ndarray:
        """
        Returns an array of objects that are converted from car reference space to global reference space.
        """
        orig_pos = np.c_[objects, np.ones(objects.shape[0])]

        rot = np.array([[math.cos(self.ref_to_car[2]), -math.sin(self.ref_to_car[2]), 0],
                        [math.sin(self.ref_to_car[2]), math.cos(self.ref_to_car[2]), 0], [0, 0, 1]])
        trans = np.array([[1, 0, self.ref_to_car[0]], [0, 1, self.ref_to_car[1]], [0, 0, 1]])
        new_pos = (trans @ rot @ orig_pos.T).T

        return new_pos[:, :-1]

    def get_front_cones_within_distance(self, cones: np.ndarray, plan_distance: float) -> np.ndarray:
        """
        Given an array of cones in the car reference space, return those that are in front and within the detection distance.

        Args:
            cones: Array of cones in car reference space. [x, y, 0|1 for blue|yellow]
            plan_distance: The maximum detection distance.
        """

        distances = np.power(cones[:, 0], 2) + np.power(cones[:, 1], 2)

        return cones[np.bitwise_and(cones[:, 0] > 0, distances < plan_distance ** 2)]

    def get_center_line(self, k: int = 500) -> np.ndarray:
        """
        Get samples from the center line of the given file

        Args:
            k: The amount of points between two center line points

        Returns:
            An array containing the x, y coordinates and angle of the center line samples
        """
        samples = []

        for i in range(len(self.track["middle_line"])):
            p0 = self.track["middle_line"][i]["M"]
            p1 = self.track["middle_line"][i]["C2"]
            p2 = self.track["middle_line"][(i + 1) % len(self.track["middle_line"])]["C1"]
            p3 = self.track["middle_line"][(i + 1) % len(self.track["middle_line"])]["M"]

            t_samples = np.linspace(0, 1, k)
            for t_index in range(len(t_samples) - 1):
                new_x_t0 = bezier_function(t_samples[t_index], p0[0], p1[0], p2[0], p3[0])
                new_y_t0 = bezier_function(t_samples[t_index], p0[1], p1[1], p2[1], p3[1])

                actual_dx = bezier_derivative(t_samples[t_index], p0[0], p1[0], p2[0], p3[0])
                actual_dy = bezier_derivative(t_samples[t_index], p0[1], p1[1], p2[1], p3[1])

                angle = math.atan2(actual_dy, actual_dx)
                angle_corrected = (angle + math.pi / 2) % (2 * math.pi) - math.pi / 2

                samples.append((new_x_t0, new_y_t0, angle_corrected))

        samples = np.array(samples)
        return samples


def bezier_function(t: float, v0: float, v1: float, v2: float, v3: float) -> float:
    part1 = pow(1 - t, 3) * v0
    part2 = 3 * pow(1 - t, 2) * t * v1
    part3 = 3 * (1 - t) * pow(t, 2) * v2
    part4 = pow(t, 3) * v3
    return part1 + part2 + part3 + part4


def bezier_derivative(t: float, v0: float, v1: float, v2: float, v3: float) -> float:
    part1 = 3 * pow(1 - t, 2) * (v1 - v0)
    part2 = 6 * (1 - t) * t * (v2 - v1)
    part3 = 3 * pow(t, 2) * (v3 - v2)
    return part1 + part2 + part3
